{
  "schema_version": "gatekeeper-artifact-v1.0",
  "timestamp": "2026-01-28T20:29:07.307907+00:00",
  "filepath": "/Users/frank/projects/claude-code-judge/repair_schema.py",
  "mode": "repair-dry-run",
  "profile": "strict",
  "summary": {
    "initial_failure_count": 3,
    "final_failure_count": 3,
    "iterations_used": 1,
    "repair_confidence": 0.0,
    "improved": false,
    "fully_repaired": false
  },
  "failures": {
    "initial": [
      "Line 109: Missing space after comma in function parameters",
      "Line 118: Missing space after comma in function parameters",
      "Line 191: Function missing docstring"
    ],
    "final": [
      "Line 109: Missing space after comma in function parameters",
      "Line 118: Missing space after comma in function parameters",
      "Line 191: Function missing docstring"
    ]
  },
  "iterations": [
    {
      "iteration": 1,
      "failures_before": 3,
      "repairs_proposed": 3,
      "repairs": [
        {
          "line": 109,
          "old": "    return '\\n'.join(lines)",
          "new": "    return '\\n'.join(lines)",
          "reason": "Missing space after comma in function parameters",
          "category": "spacing",
          "blocking": true
        },
        {
          "line": 118,
          "old": "        \"new\": \"def add(x, y):\",",
          "new": "        \"new\": \"def add(x, y):\",",
          "reason": "Missing space after comma in function parameters",
          "category": "spacing",
          "blocking": true
        },
        {
          "line": 191,
          "old": "def apply_patches_to_file(",
          "new": "def apply_patches_to_file(",
          "reason": "Function missing docstring",
          "category": "docstring",
          "blocking": true
        }
      ]
    }
  ],
  "diff": {
    "before": "\"\"\"\nRepair Schema \u2014 Structured Diff Format\n\nDefines the contract for repair proposals.\nAll repairs must conform to this schema.\n\"\"\"\n\nfrom typing import TypedDict, List\n\n\n# Schema versioning for backward compatibility\nSCHEMA_VERSION = \"1.0\"\n\n\n# Controlled vocabulary for repair categories\nALLOWED_CATEGORIES = {\n    \"spacing\",\n    \"docstring\",\n    \"naming\",\n    \"typing\",\n    \"logic\",\n    \"security\",\n}\n\n\nclass RepairPatch(TypedDict):\n    \"\"\"Single repair operation.\"\"\"\n    line: int              # Line number (1-indexed)\n    old: str              # Original line content\n    new: str              # Replacement line content\n    reason: str           # Why this change is needed\n    category: str         # Must be from ALLOWED_CATEGORIES\n    blocking: bool        # Is this a blocking failure?\n\n\nclass RepairProposal(TypedDict):\n    \"\"\"Complete repair proposal for a file.\"\"\"\n    schema_version: str\n    filepath: str\n    patches: List[RepairPatch]\n    total_changes: int\n    blocking_changes: int\n    non_blocking_changes: int\n\n\ndef validate_patch(patch: dict) -> bool:\n    \"\"\"\n    Validate that a patch conforms to schema.\n    \n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    required_keys = {\"line\", \"old\", \"new\", \"reason\", \"category\", \"blocking\"}\n    \n    if not all(key in patch for key in required_keys):\n        return False\n    \n    if not isinstance(patch[\"line\"], int) or patch[\"line\"] < 1:\n        return False\n    \n    if not all(isinstance(patch[k], str) for k in [\"old\", \"new\", \"reason\", \"category\"]):\n        return False\n    \n    if not isinstance(patch[\"blocking\"], bool):\n        return False\n    \n    # Soft validation: warn if category not in allowed set\n    if patch[\"category\"] not in ALLOWED_CATEGORIES:\n        print(f\"WARNING: Category '{patch['category']}' not in ALLOWED_CATEGORIES. Allowed: {ALLOWED_CATEGORIES}\")\n    \n    return True\n\n\ndef apply_patches_preview(original_code: str, patches: List[RepairPatch]) -> str:\n    \"\"\"\n    Preview what code would look like after applying patches.\n    Does NOT modify files - returns transformed code as string.\n    \n    Args:\n        original_code: Original source code\n        patches: List of patches to apply\n    \n    Returns:\n        Code with patches applied (preview only)\n    \"\"\"\n    lines = original_code.split('\\n')\n    \n    # Sort patches by line number (descending) to avoid index shifts\n    sorted_patches = sorted(patches, key=lambda p: p[\"line\"], reverse=True)\n    \n    for patch in sorted_patches:\n        line_idx = patch[\"line\"] - 1  # Convert to 0-indexed\n        \n        if 0 <= line_idx < len(lines):\n            # Verify old content matches (safety check - prevents silent corruption)\n            if lines[line_idx].strip() == patch[\"old\"].strip():\n                lines[line_idx] = patch[\"new\"]\n            else:\n                # Mismatch - skip this patch and log warning\n                print(f\"WARNING: Line {patch['line']} mismatch. Expected: {patch['old']}, Found: {lines[line_idx]}\")\n    \n    return '\\n'.join(lines)\n\n\n# Example usage (for testing)\nif __name__ == \"__main__\":\n    example_patch = {\n        \"line\": 1,\n        \"old\": \"def add(x,y):\",\n        \"new\": \"def add(x, y):\",\n        \"reason\": \"PEP 8: Space after comma in parameters\",\n        \"category\": \"spacing\",\n        \"blocking\": False\n    }\n    \n    print(\"Valid patch:\", validate_patch(example_patch))\n    \n    original = \"def add(x,y):\\n    return x+y\"\n    preview = apply_patches_preview(original, [example_patch])\n    print(\"\\nOriginal:\")\n    print(original)\n    print(\"\\nPreview:\")\n    print(preview)\n\n\ndef generate_diff_preview(original_code: str, patches: List[RepairPatch]) -> str:\n    \"\"\"\n    Generate a unified diff showing what would change.\n    \n    Args:\n        original_code: Original source code\n        patches: List of patches to apply\n    \n    Returns:\n        Unified diff string\n    \"\"\"\n    import difflib\n    \n    # Apply patches to get new code\n    new_code = apply_patches_preview(original_code, patches)\n    \n    # Generate unified diff\n    original_lines = original_code.splitlines(keepends=True)\n    new_lines = new_code.splitlines(keepends=True)\n    \n    diff = difflib.unified_diff(\n        original_lines,\n        new_lines,\n        fromfile='original',\n        tofile='proposed',\n        lineterm=''\n    )\n    \n    return ''.join(diff)\n\n\ndef display_preview(original_code: str, patches: List[RepairPatch]) -> None:\n    \"\"\"\n    Display a human-readable preview of changes.\n    \n    Args:\n        original_code: Original source code\n        patches: List of patches to apply\n    \"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"REPAIR PREVIEW\")\n    print(\"=\"*60)\n    \n    print(f\"\\nTotal patches: {len(patches)}\")\n    print(f\"Blocking: {sum(1 for p in patches if p.get('blocking', False))}\")\n    print(f\"Non-blocking: {sum(1 for p in patches if not p.get('blocking', False))}\")\n    \n    print(\"\\n\" + \"-\"*60)\n    print(\"PROPOSED CHANGES:\")\n    print(\"-\"*60)\n    \n    for i, patch in enumerate(patches, 1):\n        print(f\"\\n{i}. Line {patch['line']} - {patch['category']}\")\n        print(f\"   Reason: {patch['reason']}\")\n        print(f\"   - OLD: {patch['old']}\")\n        print(f\"   + NEW: {patch['new']}\")\n    \n    print(\"\\n\" + \"-\"*60)\n    print(\"UNIFIED DIFF:\")\n    print(\"-\"*60)\n    print(generate_diff_preview(original_code, patches))\n    \n    print(\"\\n\" + \"=\"*60)\n\n\ndef apply_patches_to_file(\n    filepath: str,\n    patches: List[RepairPatch],\n    dry_run: bool = True,\n    create_backup: bool = True\n) -> dict:\n    \"\"\"\n    Apply patches to a file with safety checks.\n    \n    Args:\n        filepath: Path to file\n        patches: List of patches to apply\n        dry_run: If True, don't actually write (default: True for safety)\n        create_backup: If True, create .bak file before modifying\n    \n    Returns:\n        Dict with status and details\n    \"\"\"\n    import shutil\n    from pathlib import Path\n    \n    # Read original file\n    with open(filepath, 'r') as f:\n        original_code = f.read()\n    \n    # Apply patches\n    new_code = apply_patches_preview(original_code, patches)\n    \n    # If dry-run, just return preview\n    if dry_run:\n        return {\n            \"status\": \"dry-run\",\n            \"filepath\": filepath,\n            \"patches_applied\": 0,\n            \"backup_created\": False,\n            \"preview\": new_code\n        }\n    \n    # Create backup if requested\n    backup_path = None\n    if create_backup:\n        backup_path = f\"{filepath}.bak\"\n        shutil.copy2(filepath, backup_path)\n    \n    # Write new code\n    with open(filepath, 'w') as f:\n        f.write(new_code)\n    \n    return {\n        \"status\": \"applied\",\n        \"filepath\": filepath,\n        \"patches_applied\": len(patches),\n        \"backup_created\": create_backup,\n        \"backup_path\": backup_path,\n        \"original_size\": len(original_code),\n        \"new_size\": len(new_code)\n    }\n",
    "after": "\"\"\"\nRepair Schema \u2014 Structured Diff Format\n\nDefines the contract for repair proposals.\nAll repairs must conform to this schema.\n\"\"\"\n\nfrom typing import TypedDict, List\n\n\n# Schema versioning for backward compatibility\nSCHEMA_VERSION = \"1.0\"\n\n\n# Controlled vocabulary for repair categories\nALLOWED_CATEGORIES = {\n    \"spacing\",\n    \"docstring\",\n    \"naming\",\n    \"typing\",\n    \"logic\",\n    \"security\",\n}\n\n\nclass RepairPatch(TypedDict):\n    \"\"\"Single repair operation.\"\"\"\n    line: int              # Line number (1-indexed)\n    old: str              # Original line content\n    new: str              # Replacement line content\n    reason: str           # Why this change is needed\n    category: str         # Must be from ALLOWED_CATEGORIES\n    blocking: bool        # Is this a blocking failure?\n\n\nclass RepairProposal(TypedDict):\n    \"\"\"Complete repair proposal for a file.\"\"\"\n    schema_version: str\n    filepath: str\n    patches: List[RepairPatch]\n    total_changes: int\n    blocking_changes: int\n    non_blocking_changes: int\n\n\ndef validate_patch(patch: dict) -> bool:\n    \"\"\"\n    Validate that a patch conforms to schema.\n    \n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    required_keys = {\"line\", \"old\", \"new\", \"reason\", \"category\", \"blocking\"}\n    \n    if not all(key in patch for key in required_keys):\n        return False\n    \n    if not isinstance(patch[\"line\"], int) or patch[\"line\"] < 1:\n        return False\n    \n    if not all(isinstance(patch[k], str) for k in [\"old\", \"new\", \"reason\", \"category\"]):\n        return False\n    \n    if not isinstance(patch[\"blocking\"], bool):\n        return False\n    \n    # Soft validation: warn if category not in allowed set\n    if patch[\"category\"] not in ALLOWED_CATEGORIES:\n        print(f\"WARNING: Category '{patch['category']}' not in ALLOWED_CATEGORIES. Allowed: {ALLOWED_CATEGORIES}\")\n    \n    return True\n\n\ndef apply_patches_preview(original_code: str, patches: List[RepairPatch]) -> str:\n    \"\"\"\n    Preview what code would look like after applying patches.\n    Does NOT modify files - returns transformed code as string.\n    \n    Args:\n        original_code: Original source code\n        patches: List of patches to apply\n    \n    Returns:\n        Code with patches applied (preview only)\n    \"\"\"\n    lines = original_code.split('\\n')\n    \n    # Sort patches by line number (descending) to avoid index shifts\n    sorted_patches = sorted(patches, key=lambda p: p[\"line\"], reverse=True)\n    \n    for patch in sorted_patches:\n        line_idx = patch[\"line\"] - 1  # Convert to 0-indexed\n        \n        if 0 <= line_idx < len(lines):\n            # Verify old content matches (safety check - prevents silent corruption)\n            if lines[line_idx].strip() == patch[\"old\"].strip():\n                lines[line_idx] = patch[\"new\"]\n            else:\n                # Mismatch - skip this patch and log warning\n                print(f\"WARNING: Line {patch['line']} mismatch. Expected: {patch['old']}, Found: {lines[line_idx]}\")\n    \n    return '\\n'.join(lines)\n\n\n# Example usage (for testing)\nif __name__ == \"__main__\":\n    example_patch = {\n        \"line\": 1,\n        \"old\": \"def add(x,y):\",\n        \"new\": \"def add(x, y):\",\n        \"reason\": \"PEP 8: Space after comma in parameters\",\n        \"category\": \"spacing\",\n        \"blocking\": False\n    }\n    \n    print(\"Valid patch:\", validate_patch(example_patch))\n    \n    original = \"def add(x,y):\\n    return x+y\"\n    preview = apply_patches_preview(original, [example_patch])\n    print(\"\\nOriginal:\")\n    print(original)\n    print(\"\\nPreview:\")\n    print(preview)\n\n\ndef generate_diff_preview(original_code: str, patches: List[RepairPatch]) -> str:\n    \"\"\"\n    Generate a unified diff showing what would change.\n    \n    Args:\n        original_code: Original source code\n        patches: List of patches to apply\n    \n    Returns:\n        Unified diff string\n    \"\"\"\n    import difflib\n    \n    # Apply patches to get new code\n    new_code = apply_patches_preview(original_code, patches)\n    \n    # Generate unified diff\n    original_lines = original_code.splitlines(keepends=True)\n    new_lines = new_code.splitlines(keepends=True)\n    \n    diff = difflib.unified_diff(\n        original_lines,\n        new_lines,\n        fromfile='original',\n        tofile='proposed',\n        lineterm=''\n    )\n    \n    return ''.join(diff)\n\n\ndef display_preview(original_code: str, patches: List[RepairPatch]) -> None:\n    \"\"\"\n    Display a human-readable preview of changes.\n    \n    Args:\n        original_code: Original source code\n        patches: List of patches to apply\n    \"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"REPAIR PREVIEW\")\n    print(\"=\"*60)\n    \n    print(f\"\\nTotal patches: {len(patches)}\")\n    print(f\"Blocking: {sum(1 for p in patches if p.get('blocking', False))}\")\n    print(f\"Non-blocking: {sum(1 for p in patches if not p.get('blocking', False))}\")\n    \n    print(\"\\n\" + \"-\"*60)\n    print(\"PROPOSED CHANGES:\")\n    print(\"-\"*60)\n    \n    for i, patch in enumerate(patches, 1):\n        print(f\"\\n{i}. Line {patch['line']} - {patch['category']}\")\n        print(f\"   Reason: {patch['reason']}\")\n        print(f\"   - OLD: {patch['old']}\")\n        print(f\"   + NEW: {patch['new']}\")\n    \n    print(\"\\n\" + \"-\"*60)\n    print(\"UNIFIED DIFF:\")\n    print(\"-\"*60)\n    print(generate_diff_preview(original_code, patches))\n    \n    print(\"\\n\" + \"=\"*60)\n\n\ndef apply_patches_to_file(\n    filepath: str,\n    patches: List[RepairPatch],\n    dry_run: bool = True,\n    create_backup: bool = True\n) -> dict:\n    \"\"\"\n    Apply patches to a file with safety checks.\n    \n    Args:\n        filepath: Path to file\n        patches: List of patches to apply\n        dry_run: If True, don't actually write (default: True for safety)\n        create_backup: If True, create .bak file before modifying\n    \n    Returns:\n        Dict with status and details\n    \"\"\"\n    import shutil\n    from pathlib import Path\n    \n    # Read original file\n    with open(filepath, 'r') as f:\n        original_code = f.read()\n    \n    # Apply patches\n    new_code = apply_patches_preview(original_code, patches)\n    \n    # If dry-run, just return preview\n    if dry_run:\n        return {\n            \"status\": \"dry-run\",\n            \"filepath\": filepath,\n            \"patches_applied\": 0,\n            \"backup_created\": False,\n            \"preview\": new_code\n        }\n    \n    # Create backup if requested\n    backup_path = None\n    if create_backup:\n        backup_path = f\"{filepath}.bak\"\n        shutil.copy2(filepath, backup_path)\n    \n    # Write new code\n    with open(filepath, 'w') as f:\n        f.write(new_code)\n    \n    return {\n        \"status\": \"applied\",\n        \"filepath\": filepath,\n        \"patches_applied\": len(patches),\n        \"backup_created\": create_backup,\n        \"backup_path\": backup_path,\n        \"original_size\": len(original_code),\n        \"new_size\": len(new_code)\n    }\n"
  },
  "metadata": {
    "gatekeeper_version": "1.0.0",
    "created_at": "2026-01-28T20:29:07.307907+00:00"
  }
}