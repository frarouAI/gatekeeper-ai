{
  "schema_version": "gatekeeper-artifact-v1.0",
  "timestamp": "2026-01-28T20:24:24.493489+00:00",
  "filepath": "/Users/frank/projects/claude-code-judge/.agent_backups/20260127_133123/verdict_signer.py",
  "mode": "repair-dry-run",
  "profile": "strict",
  "summary": {
    "initial_failure_count": 3,
    "final_failure_count": 0,
    "iterations_used": 1,
    "repair_confidence": 1.0,
    "improved": true,
    "fully_repaired": true
  },
  "failures": {
    "initial": [
      "Line 8: Function missing docstring",
      "Line 22: Function missing docstring",
      "Line 39: Function missing docstring"
    ],
    "final": []
  },
  "iterations": [
    {
      "iteration": 1,
      "failures_before": 3,
      "repairs_proposed": 3,
      "repairs": [
        {
          "line": 8,
          "old": "    def __init__(self, secret_key: str):",
          "new": "    def __init__(self, secret_key: str):\n        \"\"\"Initialize the VerdictSigner with a secret key.\n        \n        Args:\n            secret_key: The secret key used for signing and verification.\n            \n        Raises:\n            ValueError: If secret_key is empty.\n        \"\"\"",
          "reason": "Function missing docstring",
          "category": "docstring",
          "blocking": true
        },
        {
          "line": 22,
          "old": "    def sign(self, verdict: Dict[str, Any]) -> Dict[str, Any]:",
          "new": "    def sign(self, verdict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Sign a verdict dictionary with HMAC-SHA256.\n        \n        Args:\n            verdict: The verdict dictionary to sign.\n            \n        Returns:\n            A new dictionary containing the original verdict plus signature.\n        \"\"\"",
          "reason": "Function missing docstring",
          "category": "docstring",
          "blocking": true
        },
        {
          "line": 39,
          "old": "    def verify(self, verdict: Dict[str, Any]) -> bool:",
          "new": "    def verify(self, verdict: Dict[str, Any]) -> bool:\n        \"\"\"Verify the signature of a signed verdict.\n        \n        Args:\n            verdict: The signed verdict dictionary to verify.\n            \n        Returns:\n            True if the signature is valid, False otherwise.\n        \"\"\"",
          "reason": "Function missing docstring",
          "category": "docstring",
          "blocking": true
        }
      ]
    }
  ],
  "diff": {
    "before": "import json\nimport hmac\nimport hashlib\nfrom typing import Dict, Any\n\n\nclass VerdictSigner:\n    def __init__(self, secret_key: str):\n        if not secret_key:\n            raise ValueError(\"Signing key must not be empty\")\n        self.secret_key = secret_key.encode(\"utf-8\")\n\n    def _canonical_json(self, verdict: Dict[str, Any]) -> bytes:\n        \"\"\"\n        Deterministic JSON encoding for signing.\n        Excludes existing signature if present.\n        \"\"\"\n        clean = dict(verdict)\n        clean.pop(\"signature\", None)\n        return json.dumps(clean, sort_keys=True, separators=(\",\", \":\")).encode(\"utf-8\")\n\n    def sign(self, verdict: Dict[str, Any]) -> Dict[str, Any]:\n        payload = self._canonical_json(verdict)\n\n        sig = hmac.new(\n            self.secret_key,\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n\n        signed = dict(verdict)\n        signed[\"signature\"] = {\n            \"alg\": \"HMAC-SHA256\",\n            \"value\": sig,\n        }\n\n        return signed\n\n    def verify(self, verdict: Dict[str, Any]) -> bool:\n        sig_block = verdict.get(\"signature\")\n        if not sig_block:\n            return False\n\n        expected = sig_block.get(\"value\")\n        if not expected:\n            return False\n\n        payload = self._canonical_json(verdict)\n\n        actual = hmac.new(\n            self.secret_key,\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n\n        return hmac.compare_digest(actual, expected)\n",
    "after": "import json\nimport hmac\nimport hashlib\nfrom typing import Dict, Any\n\n\nclass VerdictSigner:\n    def __init__(self, secret_key: str):\n        \"\"\"Initialize the VerdictSigner with a secret key.\n        \n        Args:\n            secret_key: The secret key used for signing and verification.\n            \n        Raises:\n            ValueError: If secret_key is empty.\n        \"\"\"\n        if not secret_key:\n            raise ValueError(\"Signing key must not be empty\")\n        self.secret_key = secret_key.encode(\"utf-8\")\n\n    def _canonical_json(self, verdict: Dict[str, Any]) -> bytes:\n        \"\"\"\n        Deterministic JSON encoding for signing.\n        Excludes existing signature if present.\n        \"\"\"\n        clean = dict(verdict)\n        clean.pop(\"signature\", None)\n        return json.dumps(clean, sort_keys=True, separators=(\",\", \":\")).encode(\"utf-8\")\n\n    def sign(self, verdict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Sign a verdict dictionary with HMAC-SHA256.\n        \n        Args:\n            verdict: The verdict dictionary to sign.\n            \n        Returns:\n            A new dictionary containing the original verdict plus signature.\n        \"\"\"\n        payload = self._canonical_json(verdict)\n\n        sig = hmac.new(\n            self.secret_key,\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n\n        signed = dict(verdict)\n        signed[\"signature\"] = {\n            \"alg\": \"HMAC-SHA256\",\n            \"value\": sig,\n        }\n\n        return signed\n\n    def verify(self, verdict: Dict[str, Any]) -> bool:\n        \"\"\"Verify the signature of a signed verdict.\n        \n        Args:\n            verdict: The signed verdict dictionary to verify.\n            \n        Returns:\n            True if the signature is valid, False otherwise.\n        \"\"\"\n        sig_block = verdict.get(\"signature\")\n        if not sig_block:\n            return False\n\n        expected = sig_block.get(\"value\")\n        if not expected:\n            return False\n\n        payload = self._canonical_json(verdict)\n\n        actual = hmac.new(\n            self.secret_key,\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n\n        return hmac.compare_digest(actual, expected)\n"
  },
  "metadata": {
    "gatekeeper_version": "1.0.0",
    "created_at": "2026-01-28T20:24:24.493489+00:00"
  }
}