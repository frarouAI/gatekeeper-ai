{
  "schema_version": "gatekeeper-artifact-v1.0",
  "timestamp": "2026-01-28T20:25:05.805665+00:00",
  "filepath": "/Users/frank/projects/claude-code-judge/.agent_backups/20260127_133136/engines/executor.py",
  "mode": "repair-dry-run",
  "profile": "strict",
  "summary": {
    "initial_failure_count": 1,
    "final_failure_count": 1,
    "iterations_used": 1,
    "repair_confidence": 0.0,
    "improved": false,
    "fully_repaired": false
  },
  "failures": {
    "initial": [
      "Line 142: Function missing docstring"
    ],
    "final": [
      "Line 142: Function missing docstring"
    ]
  },
  "iterations": [
    {
      "iteration": 1,
      "failures_before": 1,
      "repairs_proposed": 1,
      "repairs": [
        {
          "line": 142,
          "old": "if __name__ == \"__main__\":",
          "new": "if __name__ == \"__main__\":\n    \"\"\"Run test cases to demonstrate the sandbox functionality.\"\"\"",
          "reason": "Function missing docstring - added docstring to main block",
          "category": "docstring",
          "blocking": true
        }
      ]
    }
  ],
  "diff": {
    "before": "import ast\nimport math\nimport random\nimport datetime\nimport typing\nimport itertools\nimport functools\nimport re\nimport collections\nimport operator\nimport copy\nimport json\nimport time\nimport statistics\nimport string\n\n# Allowed standard library modules for sandbox\nALLOWED_MODULES = {\n    'math': math,\n    'random': random,\n    'datetime': datetime,\n    'typing': typing,\n    'itertools': itertools,\n    'functools': functools,\n    're': re,\n    'collections': collections,\n    'operator': operator,\n    'copy': copy,\n    'json': json,\n    'time': time,\n    'statistics': statistics,\n    'string': string\n}\n\n\ndef safe_import(name, *args, **kwargs):\n    \"\"\"Restricted import that only allows whitelisted modules.\"\"\"\n    if name in ALLOWED_MODULES:\n        return ALLOWED_MODULES[name]\n    raise ImportError(f\"Import of '{name}' is not allowed\")\n\n\ndef detect_module_references(code: str) -> set:\n    \"\"\"Detect standard library module references in code using AST.\"\"\"\n    try:\n        tree = ast.parse(code)\n        modules = set()\n        \n        for node in ast.walk(tree):\n            # Detect import statements\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    if alias.name in ALLOWED_MODULES:\n                        modules.add(alias.name)\n            elif isinstance(node, ast.ImportFrom):\n                if node.module in ALLOWED_MODULES:\n                    modules.add(node.module)\n            # Detect patterns like: math.sqrt()\n            elif isinstance(node, ast.Attribute):\n                if isinstance(node.value, ast.Name):\n                    if node.value.id in ALLOWED_MODULES:\n                        modules.add(node.value.id)\n        \n        return modules\n    except SyntaxError:\n        return set()\n\n\ndef execute_code(code: str, timeout: int = 5) -> dict:\n    \"\"\"\n    Safely execute Python code in a restricted sandbox.\n    \n    Args:\n        code: Python code to execute\n        timeout: Max execution time in seconds\n        \n    Returns:\n        dict with keys: success, output, error\n    \"\"\"\n    # Build sandbox environment\n    sandbox = {\n        '__builtins__': {\n            '__import__': safe_import,\n            'print': print,\n            'len': len,\n            'range': range,\n            'str': str,\n            'int': int,\n            'float': float,\n            'bool': bool,\n            'list': list,\n            'dict': dict,\n            'set': set,\n            'tuple': tuple,\n            'enumerate': enumerate,\n            'zip': zip,\n            'map': map,\n            'filter': filter,\n            'sorted': sorted,\n            'sum': sum,\n            'min': min,\n            'max': max,\n            'abs': abs,\n            'round': round,\n            'pow': pow,\n            'isinstance': isinstance,\n            'type': type,\n            'ValueError': ValueError,\n            'TypeError': TypeError,\n            'KeyError': KeyError,\n            'IndexError': IndexError,\n            'AttributeError': AttributeError,\n        }\n    }\n    \n    # Pre-inject detected modules (optimization)\n    referenced_modules = detect_module_references(code)\n    for module_name in referenced_modules:\n        sandbox[module_name] = ALLOWED_MODULES[module_name]\n    \n    try:\n        # Execute code in sandbox\n        exec(code, sandbox)\n        return {\n            \"success\": True,\n            \"output\": \"Code executed successfully\",\n            \"error\": None\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"output\": None,\n            \"error\": f\"{type(e).__name__}: {str(e)}\"\n        }\n\n\nif __name__ == \"__main__\":\n    print(\"Test 1: Using import math\")\n    test_code1 = \"\"\"\nimport math\n\ndef calculate_hypotenuse(a, b):\n    return math.sqrt(a**2 + b**2)\n\nresult = calculate_hypotenuse(3, 4)\nprint(f\"Hypotenuse: {result}\")\n\"\"\"\n    result1 = execute_code(test_code1)\n    print(json.dumps(result1, indent=2))\n    \n    print(\"\\nTest 2: Direct math.sqrt usage\")\n    test_code2 = \"\"\"\nresult = math.sqrt(16)\nprint(f\"Square root of 16: {result}\")\n\"\"\"\n    result2 = execute_code(test_code2)\n    print(json.dumps(result2, indent=2))\n    \n    print(\"\\nTest 3: Blocked import\")\n    test_code3 = \"\"\"\nimport os\nprint(os.getcwd())\n\"\"\"\n    result3 = execute_code(test_code3)\n    print(json.dumps(result3, indent=2))\n",
    "after": "import ast\nimport math\nimport random\nimport datetime\nimport typing\nimport itertools\nimport functools\nimport re\nimport collections\nimport operator\nimport copy\nimport json\nimport time\nimport statistics\nimport string\n\n# Allowed standard library modules for sandbox\nALLOWED_MODULES = {\n    'math': math,\n    'random': random,\n    'datetime': datetime,\n    'typing': typing,\n    'itertools': itertools,\n    'functools': functools,\n    're': re,\n    'collections': collections,\n    'operator': operator,\n    'copy': copy,\n    'json': json,\n    'time': time,\n    'statistics': statistics,\n    'string': string\n}\n\n\ndef safe_import(name, *args, **kwargs):\n    \"\"\"Restricted import that only allows whitelisted modules.\"\"\"\n    if name in ALLOWED_MODULES:\n        return ALLOWED_MODULES[name]\n    raise ImportError(f\"Import of '{name}' is not allowed\")\n\n\ndef detect_module_references(code: str) -> set:\n    \"\"\"Detect standard library module references in code using AST.\"\"\"\n    try:\n        tree = ast.parse(code)\n        modules = set()\n        \n        for node in ast.walk(tree):\n            # Detect import statements\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    if alias.name in ALLOWED_MODULES:\n                        modules.add(alias.name)\n            elif isinstance(node, ast.ImportFrom):\n                if node.module in ALLOWED_MODULES:\n                    modules.add(node.module)\n            # Detect patterns like: math.sqrt()\n            elif isinstance(node, ast.Attribute):\n                if isinstance(node.value, ast.Name):\n                    if node.value.id in ALLOWED_MODULES:\n                        modules.add(node.value.id)\n        \n        return modules\n    except SyntaxError:\n        return set()\n\n\ndef execute_code(code: str, timeout: int = 5) -> dict:\n    \"\"\"\n    Safely execute Python code in a restricted sandbox.\n    \n    Args:\n        code: Python code to execute\n        timeout: Max execution time in seconds\n        \n    Returns:\n        dict with keys: success, output, error\n    \"\"\"\n    # Build sandbox environment\n    sandbox = {\n        '__builtins__': {\n            '__import__': safe_import,\n            'print': print,\n            'len': len,\n            'range': range,\n            'str': str,\n            'int': int,\n            'float': float,\n            'bool': bool,\n            'list': list,\n            'dict': dict,\n            'set': set,\n            'tuple': tuple,\n            'enumerate': enumerate,\n            'zip': zip,\n            'map': map,\n            'filter': filter,\n            'sorted': sorted,\n            'sum': sum,\n            'min': min,\n            'max': max,\n            'abs': abs,\n            'round': round,\n            'pow': pow,\n            'isinstance': isinstance,\n            'type': type,\n            'ValueError': ValueError,\n            'TypeError': TypeError,\n            'KeyError': KeyError,\n            'IndexError': IndexError,\n            'AttributeError': AttributeError,\n        }\n    }\n    \n    # Pre-inject detected modules (optimization)\n    referenced_modules = detect_module_references(code)\n    for module_name in referenced_modules:\n        sandbox[module_name] = ALLOWED_MODULES[module_name]\n    \n    try:\n        # Execute code in sandbox\n        exec(code, sandbox)\n        return {\n            \"success\": True,\n            \"output\": \"Code executed successfully\",\n            \"error\": None\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"output\": None,\n            \"error\": f\"{type(e).__name__}: {str(e)}\"\n        }\n\n\nif __name__ == \"__main__\":\n    print(\"Test 1: Using import math\")\n    test_code1 = \"\"\"\nimport math\n\ndef calculate_hypotenuse(a, b):\n    return math.sqrt(a**2 + b**2)\n\nresult = calculate_hypotenuse(3, 4)\nprint(f\"Hypotenuse: {result}\")\n\"\"\"\n    result1 = execute_code(test_code1)\n    print(json.dumps(result1, indent=2))\n    \n    print(\"\\nTest 2: Direct math.sqrt usage\")\n    test_code2 = \"\"\"\nresult = math.sqrt(16)\nprint(f\"Square root of 16: {result}\")\n\"\"\"\n    result2 = execute_code(test_code2)\n    print(json.dumps(result2, indent=2))\n    \n    print(\"\\nTest 3: Blocked import\")\n    test_code3 = \"\"\"\nimport os\nprint(os.getcwd())\n\"\"\"\n    result3 = execute_code(test_code3)\n    print(json.dumps(result3, indent=2))\n"
  },
  "metadata": {
    "gatekeeper_version": "1.0.0",
    "created_at": "2026-01-28T20:25:05.805665+00:00"
  }
}