{
  "schema_version": "gatekeeper-artifact-v1.0",
  "timestamp": "2026-01-28T20:28:56.326348+00:00",
  "filepath": "/Users/frank/projects/claude-code-judge/repair_loop.py",
  "mode": "repair-dry-run",
  "profile": "strict",
  "summary": {
    "initial_failure_count": 2,
    "final_failure_count": 0,
    "iterations_used": 1,
    "repair_confidence": 1.0,
    "improved": true,
    "fully_repaired": true
  },
  "failures": {
    "initial": [
      "Line 5: Function missing docstring",
      "Line 8: Function missing docstring"
    ],
    "final": []
  },
  "iterations": [
    {
      "iteration": 1,
      "failures_before": 2,
      "repairs_proposed": 2,
      "repairs": [
        {
          "line": 5,
          "old": "def parse_gate(output: str) -> bool:",
          "new": "def parse_gate(output: str) -> bool:\n    \"\"\"Parse gate output to determine if test passed.\"\"\"",
          "reason": "Function missing docstring",
          "category": "docstring",
          "blocking": true
        },
        {
          "line": 8,
          "old": "def repair_file(file_path: str, max_iters: int = 3):",
          "new": "def repair_file(file_path: str, max_iters: int = 3):\n    \"\"\"Repair a file by iteratively fixing issues until gate passes.\"\"\"",
          "reason": "Function missing docstring",
          "category": "docstring",
          "blocking": true
        }
      ]
    }
  ],
  "diff": {
    "before": "#!/usr/bin/env python3\nimport subprocess\nfrom pathlib import Path\n\ndef parse_gate(output: str) -> bool:\n    return '\"gate_pass\": true' in output\n\ndef repair_file(file_path: str, max_iters: int = 3):\n    path = Path(file_path)\n    for i in range(max_iters):\n        result = subprocess.run(['python3', 'claude_cli.py', str(path), '--gate'], \n                               capture_output=True, text=True)\n        print(f\"Iter {i+1}: {result.stdout}\")\n        if parse_gate(result.stdout):\n            return \"PASS\"\n        # Simulate fix (real: Claude API rewrite)\n        code = path.read_text()\n        fixed = code.replace('1/0', '10/2')\n        path.write_text(fixed)\n    return \"FAILED\"\n\n# Test broken code\nPath('submissions/broken.py').write_text('def buggy(): print(1/0)')\nprint(repair_file('submissions/broken.py'))\n",
    "after": "#!/usr/bin/env python3\nimport subprocess\nfrom pathlib import Path\n\ndef parse_gate(output: str) -> bool:\n    \"\"\"Parse gate output to determine if test passed.\"\"\"\n    return '\"gate_pass\": true' in output\n\ndef repair_file(file_path: str, max_iters: int = 3):\n    \"\"\"Repair a file by iteratively fixing issues until gate passes.\"\"\"\n    path = Path(file_path)\n    for i in range(max_iters):\n        result = subprocess.run(['python3', 'claude_cli.py', str(path), '--gate'], \n                               capture_output=True, text=True)\n        print(f\"Iter {i+1}: {result.stdout}\")\n        if parse_gate(result.stdout):\n            return \"PASS\"\n        # Simulate fix (real: Claude API rewrite)\n        code = path.read_text()\n        fixed = code.replace('1/0', '10/2')\n        path.write_text(fixed)\n    return \"FAILED\"\n\n# Test broken code\nPath('submissions/broken.py').write_text('def buggy(): print(1/0)')\nprint(repair_file('submissions/broken.py'))\n"
  },
  "metadata": {
    "gatekeeper_version": "1.0.0",
    "created_at": "2026-01-28T20:28:56.326348+00:00"
  }
}